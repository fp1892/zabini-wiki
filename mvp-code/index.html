<div class="card">
  <h2>Introduction</h2>
  <p class="kicker">
    This document provides a comprehensive technical description of the Hellcats MVP system.
    It is not a quick-start guide. Instead, it aims to document the system in a way that allows
    future developers to fully understand the design, constraints and trade-offs.
  </p>
</div>

<div class="card">
  <h2>1. Design Philosophy</h2>
  <p class="small">
    The MVP system was intentionally designed to be simple, transparent and cost-free.
    Every technical decision was made with long-term maintainability and minimal operational
    overhead in mind.
  </p>
  <ul class="small">
    <li>No backend server</li>
    <li>No user accounts</li>
    <li>No deployment pipelines</li>
    <li>No paid infrastructure</li>
  </ul>
</div>

<div class="card">
  <h2>2. Static Frontend Architecture</h2>
  <p class="small">
    The application is served entirely as static files (HTML, CSS, JavaScript) via GitHub Pages.
    This guarantees high availability and eliminates all runtime hosting costs.
  </p>
  <p class="small">
    All logic is executed client-side. The browser is considered a trusted execution environment
    only after authentication has been completed.
  </p>
</div>

<div class="card">
  <h2>3. Authentication Strategy</h2>
  <p class="small">
    Firebase Anonymous Authentication is used exclusively to satisfy Firestore security requirements.
    It does not represent a user identity in the classical sense.
  </p>
  <p class="small">
    Authentication is therefore split into two layers:
  </p>
  <ul class="small">
    <li>Technical authentication (Firebase anonymous auth)</li>
    <li>User-facing access control (password gate)</li>
  </ul>
</div>

<div class="card">
  <h2>4. Password Gate (UI-Level Access Control)</h2>
  <p class="small">
    The password gate is implemented purely at the UI level. It blocks rendering of the application
    until the correct password has been entered.
  </p>
  <p class="small">
    Passwords are never stored in plaintext. Instead, SHA-256 hashes are compared against
    values stored in Firestore.
  </p>
</div>

<div class="card">
  <h2>5. Firestore Data Model</h2>
  <p class="small">
    The entire application state is stored in a single Firestore document. This decision greatly
    simplifies synchronization and reduces the likelihood of partial or inconsistent updates.
  </p>
  <pre><code>
state/main:
  persons: Person[]
  events: Event[]
  mvpCooldown: number
  </code></pre>
</div>

<div class="card">
  <h2>6. Real-Time Synchronization</h2>
  <p class="small">
    The application subscribes to Firestore updates using a real-time listener.
    Any change to the state document is immediately propagated to all connected clients.
  </p>
  <p class="small">
    This behavior is similar to collaborative document editing systems and ensures that all users
    always see the same data.
  </p>
</div>

<div class="card">
  <h2>7. Admin Mode</h2>
  <p class="small">
    Administrative actions are intentionally separated from regular application usage.
    Admin mode is unlocked using a dedicated password and stored only in the current browser session.
  </p>
  <p class="small">
    Admin mode enables destructive operations and should therefore be used sparingly.
  </p>
</div>

<div class="card">
  <h2>8. Undo Mechanism</h2>
  <p class="small">
    Before any destructive action (import or reset), the current application state is copied
    to a dedicated undo document.
  </p>
  <p class="small">
    Undo restores the exact previous state without attempting to merge or reconcile changes.
    This guarantees deterministic behavior.
  </p>
</div>

<div class="card">
  <h2>9. Maintenance Considerations</h2>
  <p class="small">
    The system is intentionally conservative. New features should be evaluated carefully to avoid
    increasing complexity or introducing hidden state.
  </p>
</div>